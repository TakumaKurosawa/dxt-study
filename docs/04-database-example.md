# ÂÆüË∑µ‰æãÔºö„Éá„Éº„Çø„Éô„Éº„ÇπÈÄ£Êê∫

## üéØ ÁõÆÊ®ô

„Åì„ÅÆ„Ç¨„Ç§„Éâ„Åß„ÅØ„ÄÅ„Éá„Éº„Çø„Éô„Éº„Çπ„Å®ÈÄ£Êê∫„Åô„ÇãÈ´òÂ∫¶„Å™ DXT Êã°ÂºµÊ©üËÉΩ„Çí‰ΩúÊàê„Åó„Åæ„Åô„ÄÇSQLite „Å® PostgreSQL „ÅÆ‰∏°Êñπ„Å´ÂØæÂøú„Åó„ÄÅ„Çª„Ç≠„É•„Ç¢„Å™ CRUD Êìç‰Ωú„ÇíÂÆüË£Ö„Åó„Åæ„Åô„ÄÇ

## üí° Â≠¶ÁøíÂÜÖÂÆπ

- „Éá„Éº„Çø„Éô„Éº„ÇπÊé•Á∂ö„ÅÆÁÆ°ÁêÜ
- „Çª„Ç≠„É•„Ç¢„Å™ SQL „ÇØ„Ç®„É™„ÅÆÂÆüË£Ö
- CRUD Êìç‰Ωú„ÅÆÂÆåÂÖ®ÂÆüË£Ö
- Ë®≠ÂÆöÂèØËÉΩ„Å™„Éá„Éº„Çø„Éô„Éº„ÇπÈÅ∏Êäû
- „Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞„Å®„É≠„ÇÆ„É≥„Ç∞
- „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÊúÄÈÅ©Âåñ

## üìÅ „Éó„É≠„Ç∏„Çß„ÇØ„ÉàÊßãÈÄ†

```
database-connector/
‚îú‚îÄ‚îÄ manifest.json
‚îú‚îÄ‚îÄ server/
‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îÇ   ‚îú‚îÄ‚îÄ database/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sqlite.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ postgresql.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ base.js
‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îÇ       ‚îú‚îÄ‚îÄ validation.js
‚îÇ       ‚îî‚îÄ‚îÄ logger.js
‚îî‚îÄ‚îÄ assets/
    ‚îî‚îÄ‚îÄ schema.sql
```

## üîß manifest.json „ÅÆË®≠ÂÆö

```json
{
  "dxt_version": "0.1",
  "name": "database-connector",
  "version": "2.0.0",
  "description": "„Çª„Ç≠„É•„Ç¢„Å™„Éá„Éº„Çø„Éô„Éº„ÇπÈÄ£Êê∫Êã°ÂºµÊ©üËÉΩ",
  "author": {
    "name": "DXT Tutorial",
    "email": "tutorial@example.com"
  },
  "server": {
    "type": "node",
    "entry_point": "server/index.js",
    "mcp_config": {
      "command": "node",
      "args": ["${__dirname}/server/index.js"]
    }
  },
  "user_settings": [
    {
      "name": "database_type",
      "type": "choice",
      "choices": ["sqlite", "postgresql"],
      "default": "sqlite",
      "description": "‰ΩøÁî®„Åô„Çã„Éá„Éº„Çø„Éô„Éº„Çπ„ÅÆÁ®ÆÈ°û"
    },
    {
      "name": "database_path",
      "type": "string",
      "default": "./data/app.db",
      "description": "SQLite „Éá„Éº„Çø„Éô„Éº„Çπ„Éï„Ç°„Ç§„É´„ÅÆ„Éë„Çπ"
    },
    {
      "name": "postgresql_url",
      "type": "string",
      "secure": true,
      "description": "PostgreSQL Êé•Á∂ö URL (postgresql://user:pass@host:port/db)"
    },
    {
      "name": "max_results",
      "type": "number",
      "default": 100,
      "description": "„ÇØ„Ç®„É™ÁµêÊûú„ÅÆÊúÄÂ§ß‰ª∂Êï∞"
    },
    {
      "name": "enable_logging",
      "type": "boolean",
      "default": true,
      "description": "Ë©≥Á¥∞„É≠„Ç∞„ÇíÊúâÂäπ„Å´„Åô„Çã"
    }
  ],
  "permissions": ["filesystem", "network"]
}
```

## üì¶ package.json „ÅÆË®≠ÂÆö

`server/package.json`:

```json
{
  "name": "database-connector-server",
  "version": "2.0.0",
  "type": "module",
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.0.0",
    "sqlite3": "^5.1.6",
    "pg": "^8.11.3",
    "joi": "^17.11.0"
  },
  "scripts": {
    "start": "node index.js"
  }
}
```

## üóÑÔ∏è „Éá„Éº„Çø„Éô„Éº„ÇπÂü∫Â∫ï„ÇØ„É©„Çπ

`server/database/base.js`:

```javascript
export class DatabaseBase {
  constructor(config) {
    this.config = config;
    this.connection = null;
  }

  async connect() {
    throw new Error("connect() must be implemented");
  }

  async disconnect() {
    throw new Error("disconnect() must be implemented");
  }

  async execute(query, params = []) {
    throw new Error("execute() must be implemented");
  }

  async select(query, params = []) {
    throw new Error("select() must be implemented");
  }

  escapeIdentifier(identifier) {
    // SQLË≠òÂà•Â≠ê„Çí„Ç®„Çπ„Ç±„Éº„Éó
    return identifier.replace(/[^a-zA-Z0-9_]/g, "");
  }

  validateTableName(tableName) {
    if (!/^[a-zA-Z][a-zA-Z0-9_]*$/.test(tableName)) {
      throw new Error("Invalid table name");
    }
    return tableName;
  }
}
```

## üóÉÔ∏è SQLite ÂÆüË£Ö

`server/database/sqlite.js`:

```javascript
import sqlite3 from "sqlite3";
import { DatabaseBase } from "./base.js";
import fs from "fs/promises";
import path from "path";

export class SQLiteDatabase extends DatabaseBase {
  constructor(config) {
    super(config);
    this.dbPath = config.database_path;
  }

  async connect() {
    try {
      // „Éá„Ç£„É¨„ÇØ„Éà„É™„ÅåÂ≠òÂú®„Åó„Å™„ÅÑÂ†¥Âêà„ÅØ‰ΩúÊàê
      const dir = path.dirname(this.dbPath);
      await fs.mkdir(dir, { recursive: true });

      return new Promise((resolve, reject) => {
        this.connection = new sqlite3.Database(this.dbPath, (err) => {
          if (err) reject(err);
          else resolve();
        });
      });
    } catch (error) {
      throw new Error(`SQLite connection failed: ${error.message}`);
    }
  }

  async disconnect() {
    if (this.connection) {
      return new Promise((resolve) => {
        this.connection.close(resolve);
      });
    }
  }

  async execute(query, params = []) {
    return new Promise((resolve, reject) => {
      this.connection.run(query, params, function (err) {
        if (err) reject(err);
        else
          resolve({
            changes: this.changes,
            lastID: this.lastID,
          });
      });
    });
  }

  async select(query, params = []) {
    return new Promise((resolve, reject) => {
      this.connection.all(query, params, (err, rows) => {
        if (err) reject(err);
        else resolve(rows);
      });
    });
  }

  async getTableInfo(tableName) {
    const validTableName = this.validateTableName(tableName);
    const query = `PRAGMA table_info(${validTableName})`;
    return await this.select(query);
  }

  async getTables() {
    const query = `
      SELECT name FROM sqlite_master 
      WHERE type='table' AND name NOT LIKE 'sqlite_%'
      ORDER BY name
    `;
    return await this.select(query);
  }
}
```

## üêò PostgreSQL ÂÆüË£Ö

`server/database/postgresql.js`:

```javascript
import pg from "pg";
import { DatabaseBase } from "./base.js";

const { Client } = pg;

export class PostgreSQLDatabase extends DatabaseBase {
  constructor(config) {
    super(config);
    this.connectionString = config.postgresql_url;
  }

  async connect() {
    try {
      this.connection = new Client({
        connectionString: this.connectionString,
        ssl: this.connectionString.includes("sslmode=require")
          ? { rejectUnauthorized: false }
          : false,
      });
      await this.connection.connect();
    } catch (error) {
      throw new Error(`PostgreSQL connection failed: ${error.message}`);
    }
  }

  async disconnect() {
    if (this.connection) {
      await this.connection.end();
    }
  }

  async execute(query, params = []) {
    try {
      const result = await this.connection.query(query, params);
      return {
        changes: result.rowCount,
        rows: result.rows,
      };
    } catch (error) {
      throw new Error(`Query execution failed: ${error.message}`);
    }
  }

  async select(query, params = []) {
    try {
      const result = await this.connection.query(query, params);
      return result.rows;
    } catch (error) {
      throw new Error(`Query execution failed: ${error.message}`);
    }
  }

  async getTableInfo(tableName) {
    const validTableName = this.validateTableName(tableName);
    const query = `
      SELECT 
        column_name, 
        data_type, 
        is_nullable,
        column_default
      FROM information_schema.columns 
      WHERE table_name = $1
      ORDER BY ordinal_position
    `;
    return await this.select(query, [validTableName]);
  }

  async getTables() {
    const query = `
      SELECT table_name as name
      FROM information_schema.tables 
      WHERE table_schema = 'public'
      ORDER BY table_name
    `;
    return await this.select(query);
  }
}
```

## üîç „Éê„É™„Éá„Éº„Ç∑„Éß„É≥Ê©üËÉΩ

`server/utils/validation.js`:

```javascript
import Joi from "joi";

export class Validator {
  static schemas = {
    tableName: Joi.string()
      .pattern(/^[a-zA-Z][a-zA-Z0-9_]*$/)
      .required(),
    columnName: Joi.string()
      .pattern(/^[a-zA-Z][a-zA-Z0-9_]*$/)
      .required(),
    limit: Joi.number().integer().min(1).max(1000).default(100),
    offset: Joi.number().integer().min(0).default(0),
    whereClause: Joi.string().max(500).optional(),
    orderBy: Joi.string()
      .pattern(/^[a-zA-Z][a-zA-Z0-9_]*( (ASC|DESC))?$/)
      .optional(),
  };

  static validateTableName(tableName) {
    const { error, value } = this.schemas.tableName.validate(tableName);
    if (error) throw new Error(`Invalid table name: ${error.message}`);
    return value;
  }

  static validateQueryParams(params) {
    const schema = Joi.object({
      table: this.schemas.tableName,
      columns: Joi.array().items(this.schemas.columnName).optional(),
      where: this.schemas.whereClause,
      orderBy: this.schemas.orderBy,
      limit: this.schemas.limit,
      offset: this.schemas.offset,
    });

    const { error, value } = schema.validate(params);
    if (error) throw new Error(`Invalid parameters: ${error.message}`);
    return value;
  }

  static validateInsertData(data) {
    if (!data || typeof data !== "object") {
      throw new Error("Insert data must be an object");
    }

    const validatedData = {};
    for (const [key, value] of Object.entries(data)) {
      // „Ç´„É©„É†Âêç„ÅÆÊ§úË®º
      const { error } = this.schemas.columnName.validate(key);
      if (error) throw new Error(`Invalid column name: ${key}`);

      validatedData[key] = value;
    }

    return validatedData;
  }
}
```

## üìù „É≠„Ç¨„ÉºÊ©üËÉΩ

`server/utils/logger.js`:

```javascript
export class Logger {
  constructor(enableLogging = true) {
    this.enableLogging = enableLogging;
  }

  log(level, message, meta = {}) {
    if (!this.enableLogging) return;

    const timestamp = new Date().toISOString();
    const logEntry = {
      timestamp,
      level,
      message,
      ...meta,
    };

    console.log(JSON.stringify(logEntry));
  }

  info(message, meta = {}) {
    this.log("info", message, meta);
  }

  error(message, meta = {}) {
    this.log("error", message, meta);
  }

  warn(message, meta = {}) {
    this.log("warn", message, meta);
  }

  debug(message, meta = {}) {
    this.log("debug", message, meta);
  }
}
```

## üñ•Ô∏è „É°„Ç§„É≥„Çµ„Éº„Éê„ÉºÂÆüË£Ö

`server/index.js`:

```javascript
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
  ListToolsRequestSchema,
  CallToolRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";

import { SQLiteDatabase } from "./database/sqlite.js";
import { PostgreSQLDatabase } from "./database/postgresql.js";
import { Validator } from "./utils/validation.js";
import { Logger } from "./utils/logger.js";

class DatabaseConnector {
  constructor() {
    this.db = null;
    this.logger = new Logger(process.env.ENABLE_LOGGING === "true");
    this.config = this.loadConfig();
    this.server = this.createServer();
  }

  loadConfig() {
    return {
      database_type: process.env.DATABASE_TYPE || "sqlite",
      database_path: process.env.DATABASE_PATH || "./data/app.db",
      postgresql_url: process.env.POSTGRESQL_URL,
      max_results: parseInt(process.env.MAX_RESULTS) || 100,
      enable_logging: process.env.ENABLE_LOGGING === "true",
    };
  }

  async initializeDatabase() {
    try {
      if (this.config.database_type === "postgresql") {
        if (!this.config.postgresql_url) {
          throw new Error("PostgreSQL URL is required");
        }
        this.db = new PostgreSQLDatabase(this.config);
      } else {
        this.db = new SQLiteDatabase(this.config);
      }

      await this.db.connect();
      this.logger.info("Database connected", {
        type: this.config.database_type,
      });
    } catch (error) {
      this.logger.error("Database initialization failed", {
        error: error.message,
      });
      throw error;
    }
  }

  createServer() {
    const server = new Server(
      {
        name: "Database Connector",
        version: "2.0.0",
      },
      {
        capabilities: {
          tools: {},
        },
      }
    );

    this.setupToolHandlers(server);
    return server;
  }

  setupToolHandlers(server) {
    // „ÉÑ„Éº„É´‰∏ÄË¶ß„ÅÆÂÆöÁæ©
    server.setRequestHandler(ListToolsRequestSchema, async () => ({
      tools: [
        {
          name: "db_list_tables",
          description: "„Éá„Éº„Çø„Éô„Éº„ÇπÂÜÖ„ÅÆ„ÉÜ„Éº„Éñ„É´‰∏ÄË¶ß„ÇíÂèñÂæó",
          inputSchema: {
            type: "object",
            properties: {},
          },
        },
        {
          name: "db_describe_table",
          description: "„ÉÜ„Éº„Éñ„É´„ÅÆÊßãÈÄ†„ÇíÂèñÂæó",
          inputSchema: {
            type: "object",
            properties: {
              table: {
                type: "string",
                description: "„ÉÜ„Éº„Éñ„É´Âêç",
              },
            },
            required: ["table"],
          },
        },
        {
          name: "db_select",
          description: "SELECT „ÇØ„Ç®„É™„ÅÆÂÆüË°å",
          inputSchema: {
            type: "object",
            properties: {
              table: {
                type: "string",
                description: "„ÉÜ„Éº„Éñ„É´Âêç",
              },
              columns: {
                type: "array",
                items: { type: "string" },
                description: "ÂèñÂæó„Åô„Çã„Ç´„É©„É†ÔºàÁúÅÁï•ÊôÇ„ÅØÂÖ®„Ç´„É©„É†Ôºâ",
              },
              where: {
                type: "string",
                description: "WHERE Êù°‰ª∂",
              },
              orderBy: {
                type: "string",
                description: "ORDER BY ÊåáÂÆö",
              },
              limit: {
                type: "number",
                description: "ÂèñÂæó‰ª∂Êï∞Âà∂Èôê",
                minimum: 1,
                maximum: 1000,
              },
              offset: {
                type: "number",
                description: "„Ç™„Éï„Çª„ÉÉ„Éà",
                minimum: 0,
              },
            },
            required: ["table"],
          },
        },
        {
          name: "db_insert",
          description: "„Éá„Éº„Çø„ÅÆÊåøÂÖ•",
          inputSchema: {
            type: "object",
            properties: {
              table: {
                type: "string",
                description: "„ÉÜ„Éº„Éñ„É´Âêç",
              },
              data: {
                type: "object",
                description: "ÊåøÂÖ•„Åô„Çã„Éá„Éº„ÇøÔºà„Ç≠„ÉºÔºö„Ç´„É©„É†Âêç„ÄÅÂÄ§Ôºö„Éá„Éº„ÇøÔºâ",
              },
            },
            required: ["table", "data"],
          },
        },
        {
          name: "db_update",
          description: "„Éá„Éº„Çø„ÅÆÊõ¥Êñ∞",
          inputSchema: {
            type: "object",
            properties: {
              table: {
                type: "string",
                description: "„ÉÜ„Éº„Éñ„É´Âêç",
              },
              data: {
                type: "object",
                description: "Êõ¥Êñ∞„Åô„Çã„Éá„Éº„Çø",
              },
              where: {
                type: "string",
                description: "WHERE Êù°‰ª∂ÔºàÂøÖÈ†àÔºâ",
              },
            },
            required: ["table", "data", "where"],
          },
        },
        {
          name: "db_delete",
          description: "„Éá„Éº„Çø„ÅÆÂâäÈô§",
          inputSchema: {
            type: "object",
            properties: {
              table: {
                type: "string",
                description: "„ÉÜ„Éº„Éñ„É´Âêç",
              },
              where: {
                type: "string",
                description: "WHERE Êù°‰ª∂ÔºàÂøÖÈ†àÔºâ",
              },
            },
            required: ["table", "where"],
          },
        },
        {
          name: "db_execute_sql",
          description: "‰ªªÊÑè„ÅÆSQL„ÇØ„Ç®„É™„ÅÆÂÆüË°åÔºà‰∏äÁ¥öËÄÖÂêë„ÅëÔºâ",
          inputSchema: {
            type: "object",
            properties: {
              sql: {
                type: "string",
                description: "ÂÆüË°å„Åô„ÇãSQL„ÇØ„Ç®„É™",
              },
              params: {
                type: "array",
                description: "SQL„Éë„É©„É°„Éº„Çø",
              },
            },
            required: ["sql"],
          },
        },
      ],
    }));

    // „ÉÑ„Éº„É´„ÅÆÂÆüË£Ö
    server.setRequestHandler(CallToolRequestSchema, async (request) => {
      const { name, arguments: args } = request.params;

      try {
        let result;

        switch (name) {
          case "db_list_tables":
            result = await this.handleListTables();
            break;

          case "db_describe_table":
            result = await this.handleDescribeTable(args);
            break;

          case "db_select":
            result = await this.handleSelect(args);
            break;

          case "db_insert":
            result = await this.handleInsert(args);
            break;

          case "db_update":
            result = await this.handleUpdate(args);
            break;

          case "db_delete":
            result = await this.handleDelete(args);
            break;

          case "db_execute_sql":
            result = await this.handleExecuteSQL(args);
            break;

          default:
            throw new Error(`Unknown tool: ${name}`);
        }

        return {
          content: [
            {
              type: "text",
              text: result,
            },
          ],
        };
      } catch (error) {
        this.logger.error(`Tool execution failed: ${name}`, {
          error: error.message,
          args,
        });

        return {
          content: [
            {
              type: "text",
              text: `„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: ${error.message}`,
            },
          ],
          isError: true,
        };
      }
    });
  }

  // „Éè„É≥„Éâ„É©„Éº„É°„ÇΩ„ÉÉ„Éâ„ÅÆÂÆüË£Ö
  async handleListTables() {
    const tables = await this.db.getTables();
    this.logger.info("Listed tables", { count: tables.length });

    return JSON.stringify(
      {
        success: true,
        tables: tables,
        count: tables.length,
      },
      null,
      2
    );
  }

  async handleDescribeTable(args) {
    const tableName = Validator.validateTableName(args.table);
    const tableInfo = await this.db.getTableInfo(tableName);

    this.logger.info("Described table", { table: tableName });

    return JSON.stringify(
      {
        success: true,
        table: tableName,
        columns: tableInfo,
      },
      null,
      2
    );
  }

  async handleSelect(args) {
    const validated = Validator.validateQueryParams(args);
    const { table, columns, where, orderBy, limit, offset } = validated;

    // „ÇØ„Ç®„É™ÊßãÁØâ
    let query = `SELECT ${columns ? columns.join(", ") : "*"} FROM ${table}`;
    const params = [];
    let paramIndex = 1;

    if (where) {
      query += ` WHERE ${where}`;
    }

    if (orderBy) {
      query += ` ORDER BY ${orderBy}`;
    }

    const actualLimit = Math.min(
      limit || this.config.max_results,
      this.config.max_results
    );

    if (this.config.database_type === "postgresql") {
      query += ` LIMIT $${paramIndex++}`;
      params.push(actualLimit);

      if (offset) {
        query += ` OFFSET $${paramIndex}`;
        params.push(offset);
      }
    } else {
      query += ` LIMIT ${actualLimit}`;
      if (offset) {
        query += ` OFFSET ${offset}`;
      }
    }

    const results = await this.db.select(query, params);

    this.logger.info("Executed SELECT", {
      table,
      rows: results.length,
      query: query.replace(/\s+/g, " "),
    });

    return JSON.stringify(
      {
        success: true,
        table,
        query: query.replace(/\s+/g, " "),
        rowCount: results.length,
        data: results,
      },
      null,
      2
    );
  }

  async handleInsert(args) {
    const tableName = Validator.validateTableName(args.table);
    const data = Validator.validateInsertData(args.data);

    const columns = Object.keys(data);
    const values = Object.values(data);

    let query, params;

    if (this.config.database_type === "postgresql") {
      const placeholders = values.map((_, i) => `$${i + 1}`).join(", ");
      query = `INSERT INTO ${tableName} (${columns.join(
        ", "
      )}) VALUES (${placeholders})`;
      params = values;
    } else {
      const placeholders = values.map(() => "?").join(", ");
      query = `INSERT INTO ${tableName} (${columns.join(
        ", "
      )}) VALUES (${placeholders})`;
      params = values;
    }

    const result = await this.db.execute(query, params);

    this.logger.info("Executed INSERT", {
      table: tableName,
      changes: result.changes,
      lastID: result.lastID,
    });

    return JSON.stringify(
      {
        success: true,
        table: tableName,
        changes: result.changes,
        lastID: result.lastID,
        insertedData: data,
      },
      null,
      2
    );
  }

  async handleUpdate(args) {
    const tableName = Validator.validateTableName(args.table);
    const data = Validator.validateInsertData(args.data);
    const where = args.where;

    if (!where || where.trim() === "") {
      throw new Error("WHERE clause is required for UPDATE operations");
    }

    const setParts = Object.keys(data).map((col, i) => {
      if (this.config.database_type === "postgresql") {
        return `${col} = $${i + 1}`;
      } else {
        return `${col} = ?`;
      }
    });

    let query = `UPDATE ${tableName} SET ${setParts.join(", ")} WHERE ${where}`;
    const params = Object.values(data);

    const result = await this.db.execute(query, params);

    this.logger.info("Executed UPDATE", {
      table: tableName,
      changes: result.changes,
    });

    return JSON.stringify(
      {
        success: true,
        table: tableName,
        changes: result.changes,
        updatedData: data,
        whereClause: where,
      },
      null,
      2
    );
  }

  async handleDelete(args) {
    const tableName = Validator.validateTableName(args.table);
    const where = args.where;

    if (!where || where.trim() === "") {
      throw new Error("WHERE clause is required for DELETE operations");
    }

    const query = `DELETE FROM ${tableName} WHERE ${where}`;
    const result = await this.db.execute(query);

    this.logger.info("Executed DELETE", {
      table: tableName,
      changes: result.changes,
    });

    return JSON.stringify(
      {
        success: true,
        table: tableName,
        changes: result.changes,
        whereClause: where,
      },
      null,
      2
    );
  }

  async handleExecuteSQL(args) {
    const { sql, params = [] } = args;

    // Âç±Èô∫„Å™SQLÊìç‰Ωú„ÅÆÊ§úÂá∫
    const dangerousPatterns = [
      /DROP\s+(?:TABLE|DATABASE|SCHEMA)/i,
      /ALTER\s+TABLE.*DROP/i,
      /TRUNCATE/i,
      /DELETE\s+FROM\s+\w+\s*(?:WHERE\s+1=1|WHERE\s+TRUE|;)/i,
    ];

    for (const pattern of dangerousPatterns) {
      if (pattern.test(sql)) {
        throw new Error("Potentially dangerous SQL operation detected");
      }
    }

    let result;
    if (sql.trim().toUpperCase().startsWith("SELECT")) {
      result = await this.db.select(sql, params);
      this.logger.info("Executed custom SELECT", {
        rows: result.length,
      });

      return JSON.stringify(
        {
          success: true,
          type: "SELECT",
          rowCount: result.length,
          data: result,
        },
        null,
        2
      );
    } else {
      result = await this.db.execute(sql, params);
      this.logger.info("Executed custom SQL", {
        changes: result.changes,
      });

      return JSON.stringify(
        {
          success: true,
          type: "MODIFY",
          changes: result.changes,
          lastID: result.lastID,
        },
        null,
        2
      );
    }
  }

  async start() {
    try {
      await this.initializeDatabase();

      const transport = new StdioServerTransport();
      await this.server.connect(transport);

      this.logger.info("Database connector server started");
    } catch (error) {
      this.logger.error("Failed to start server", { error: error.message });
      process.exit(1);
    }
  }

  async stop() {
    if (this.db) {
      await this.db.disconnect();
      this.logger.info("Database disconnected");
    }
  }
}

// „Çµ„Éº„Éê„Éº„ÅÆËµ∑Âãï
const connector = new DatabaseConnector();

// ÁµÇ‰∫Ü„Ç∑„Ç∞„Éä„É´„ÅÆÂá¶ÁêÜ
process.on("SIGINT", async () => {
  console.log("\nShutting down gracefully...");
  await connector.stop();
  process.exit(0);
});

process.on("SIGTERM", async () => {
  console.log("\nShutting down gracefully...");
  await connector.stop();
  process.exit(0);
});

// „Çµ„Éº„Éê„ÉºÈñãÂßã
connector.start().catch((error) => {
  console.error("Failed to start server:", error);
  process.exit(1);
});
```

## üöÄ ÂÆüË£Ö„Å®„ÉÜ„Çπ„Éà

### 1. „Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆ‰ΩúÊàê

```bash
# DXT„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÂàùÊúüÂåñ
dxt init database-connector
cd database-connector

# ÂøÖË¶Å„Å™„Éá„Ç£„É¨„ÇØ„Éà„É™„ÅÆ‰ΩúÊàê
mkdir -p server/database server/utils assets
```

### 2. ‰æùÂ≠òÈñ¢‰øÇ„ÅÆ„Ç§„É≥„Çπ„Éà„Éº„É´

```bash
cd server
npm install @modelcontextprotocol/sdk sqlite3 pg joi
```

### 3. „Çµ„É≥„Éó„É´„Éá„Éº„Çø„ÅÆÊ∫ñÂÇô

`assets/schema.sql`:

```sql
-- „É¶„Éº„Ç∂„Éº„ÉÜ„Éº„Éñ„É´
CREATE TABLE users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    email TEXT UNIQUE NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- „Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÉÜ„Éº„Éñ„É´
CREATE TABLE projects (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    description TEXT,
    user_id INTEGER,
    status TEXT DEFAULT 'active',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users (id)
);

-- „Çµ„É≥„Éó„É´„Éá„Éº„Çø
INSERT INTO users (name, email) VALUES
('Alice Johnson', 'alice@example.com'),
('Bob Smith', 'bob@example.com'),
('Carol Davis', 'carol@example.com');

INSERT INTO projects (name, description, user_id, status) VALUES
('Website Redesign', 'Complete redesign of company website', 1, 'active'),
('Mobile App', 'iOS and Android app development', 2, 'active'),
('Data Migration', 'Legacy system data migration', 1, 'completed'),
('API Integration', 'Third-party API integration', 3, 'active');
```

### 4. „É≠„Éº„Ç´„É´„ÉÜ„Çπ„Éà

```bash
# SQLite„ÅßÂü∫Êú¨„ÉÜ„Çπ„Éà
cd server
DATABASE_TYPE=sqlite DATABASE_PATH=./test.db ENABLE_LOGGING=true node index.js

# Âà•„ÅÆ„Çø„Éº„Éü„Éä„É´„Åß„ÉÜ„Çπ„Éà
echo '{"jsonrpc": "2.0", "id": 1, "method": "tools/list"}' | node index.js
```

### 5. DXT „Éï„Ç°„Ç§„É´„ÅÆ‰ΩúÊàê

```bash
# „Éó„É≠„Ç∏„Çß„ÇØ„Éà„É´„Éº„Éà„Å´Êàª„Çã
cd ..

# DXT„Éï„Ç°„Ç§„É´„Çí‰ΩúÊàê
dxt pack

# ‰ΩúÊàê„Åï„Çå„Åü„Éï„Ç°„Ç§„É´„ÇíÁ¢∫Ë™ç
ls -la *.dxt
```

## üß™ ‰ΩøÁî®‰æã

### Claude Desktop „Åß„ÅÆ‰ΩøÁî®

1. **„ÉÜ„Éº„Éñ„É´‰∏ÄË¶ß„ÅÆÂèñÂæó**:

   ```
   Âà©Áî®ÂèØËÉΩ„Å™„ÉÜ„Éº„Éñ„É´„ÇíÊïô„Åà„Å¶„Åè„Å†„Åï„ÅÑ
   ```

2. **„Éá„Éº„Çø„ÅÆÊ§úÁ¥¢**:

   ```
   users„ÉÜ„Éº„Éñ„É´„Åã„ÇâÂÖ®„Å¶„ÅÆ„É¶„Éº„Ç∂„ÉºÊÉÖÂ†±„ÇíÂèñÂæó„Åó„Å¶„Åè„Å†„Åï„ÅÑ
   ```

3. **„Éá„Éº„Çø„ÅÆÊåøÂÖ•**:

   ```
   users„ÉÜ„Éº„Éñ„É´„Å´Êñ∞„Åó„ÅÑ„É¶„Éº„Ç∂„Éº„ÄåDavid Wilson (david@example.com)„Äç„ÇíËøΩÂä†„Åó„Å¶„Åè„Å†„Åï„ÅÑ
   ```

4. **„Éá„Éº„Çø„ÅÆÊõ¥Êñ∞**:

   ```
   „É¶„Éº„Ç∂„ÉºID 1 „ÅÆ„É°„Éº„É´„Ç¢„Éâ„É¨„Çπ„Çí "alice.new@example.com" „Å´Êõ¥Êñ∞„Åó„Å¶„Åè„Å†„Åï„ÅÑ
   ```

5. **Ë§áÈõë„Å™„ÇØ„Ç®„É™**:
   ```
   „Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Å™„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÇíÊåÅ„Å§„É¶„Éº„Ç∂„Éº„ÅÆ‰∏ÄË¶ß„ÇíÂèñÂæó„Åó„Å¶„Åè„Å†„Åï„ÅÑ
   ```

### ÊúüÂæÖ„Åï„Çå„ÇãÁµêÊûú

```json
{
  "success": true,
  "table": "users",
  "rowCount": 3,
  "data": [
    {
      "id": 1,
      "name": "Alice Johnson",
      "email": "alice@example.com",
      "created_at": "2024-01-15 10:30:00"
    },
    {
      "id": 2,
      "name": "Bob Smith",
      "email": "bob@example.com",
      "created_at": "2024-01-15 11:15:00"
    }
  ]
}
```

## üîß Ë®≠ÂÆö‰æã

### SQLite Ë®≠ÂÆöÔºàÈñãÁô∫Áî®Ôºâ

```json
{
  "database_type": "sqlite",
  "database_path": "./data/myapp.db",
  "max_results": 50,
  "enable_logging": true
}
```

### PostgreSQL Ë®≠ÂÆöÔºàÊú¨Áï™Áî®Ôºâ

```json
{
  "database_type": "postgresql",
  "postgresql_url": "postgresql://user:pass@localhost:5432/mydb",
  "max_results": 100,
  "enable_logging": false
}
```

## üö® „Éà„É©„Éñ„É´„Ç∑„É•„Éº„ÉÜ„Ç£„É≥„Ç∞

### „Çà„Åè„ÅÇ„ÇãÂïèÈ°å

#### 1. „Éá„Éº„Çø„Éô„Éº„ÇπÊé•Á∂ö„Ç®„É©„Éº

```
„Ç®„É©„Éº: PostgreSQL connection failed: connect ECONNREFUSED
```

**Ëß£Ê±∫Á≠ñ**:

- PostgreSQL „Çµ„Éº„Éê„Éº„ÅåËµ∑Âãï„Åó„Å¶„ÅÑ„Çã„ÅãÁ¢∫Ë™ç
- Êé•Á∂ö URL „ÅåÊ≠£„Åó„ÅÑ„ÅãÁ¢∫Ë™ç
- „Éï„Ç°„Ç§„Ç¢„Ç¶„Ç©„Éº„É´Ë®≠ÂÆö„ÇíÁ¢∫Ë™ç

#### 2. „ÉÜ„Éº„Éñ„É´„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑ

```
„Ç®„É©„Éº: relation "users" does not exist
```

**Ëß£Ê±∫Á≠ñ**:

- „ÉÜ„Éº„Éñ„É´Âêç„ÅÆÂ§ßÊñáÂ≠óÂ∞èÊñáÂ≠ó„ÇíÁ¢∫Ë™ç
- „Çπ„Ç≠„Éº„Éû„ÅåÊ≠£„Åó„ÅèÈÅ©Áî®„Åï„Çå„Å¶„ÅÑ„Çã„ÅãÁ¢∫Ë™ç
- „Éá„Éº„Çø„Éô„Éº„Çπ„ÅåÊ≠£„Åó„ÅèÈÅ∏Êäû„Åï„Çå„Å¶„ÅÑ„Çã„ÅãÁ¢∫Ë™ç

#### 3. Ê®©Èôê„Ç®„É©„Éº

```
„Ç®„É©„Éº: permission denied for table users
```

**Ëß£Ê±∫Á≠ñ**:

- „Éá„Éº„Çø„Éô„Éº„Çπ„É¶„Éº„Ç∂„Éº„ÅÆÊ®©Èôê„ÇíÁ¢∫Ë™ç
- GRANT Êñá„ÅßÈÅ©Âàá„Å™Ê®©Èôê„Çí‰ªò‰∏é

### „Éá„Éê„ÉÉ„Ç∞ÊñπÊ≥ï

```bash
# Ë©≥Á¥∞„É≠„Ç∞„ÇíÊúâÂäπ„Å´„Åó„Å¶„ÉÜ„Çπ„Éà
ENABLE_LOGGING=true DEBUG=* node server/index.js

# SQL„ÇØ„Ç®„É™„ÅÆÁ¢∫Ë™ç
console.log("Executing query:", query, "with params:", params);
```

## üéØ ÂÆüË∑µÁöÑ„Å™Ê¥ªÁî®‰æã

### 1. Âñ∂Ê•≠„Éá„Éº„ÇøÂàÜÊûê

```
‰ªäÊúà„ÅÆÂ£≤‰∏ä‰∏ä‰Ωç10‰ª∂„ÅÆÊ°à‰ª∂„ÇíÂèñÂæó„Åó„ÄÅÊãÖÂΩìËÄÖ„Åî„Å®„Å´ÈõÜË®à„Åó„Å¶„Åè„Å†„Åï„ÅÑ
```

### 2. È°ßÂÆ¢„Çµ„Éù„Éº„Éà

```
ÈÅéÂéª30Êó•Èñì„ÅÆ„Çµ„Éù„Éº„Éà„ÉÅ„Ç±„ÉÉ„Éà„ÇíÈáçË¶ÅÂ∫¶Âà•„Å´ÂàÜÈ°û„Åó„ÄÅÊú™Ëß£Ê±∫„ÅÆ„ÇÇ„ÅÆ„Çí‰∏ÄË¶ßË°®Á§∫„Åó„Å¶„Åè„Å†„Åï„ÅÑ
```

### 3. Âú®Â∫´ÁÆ°ÁêÜ

```
Âú®Â∫´„Åå10ÂÄãÊú™Ê∫Ä„ÅÆÂïÜÂìÅ„ÇíÊäΩÂá∫„Åó„ÄÅÁô∫Ê≥®„ÅåÂøÖË¶Å„Å™ÂïÜÂìÅ„É™„Çπ„Éà„Çí‰ΩúÊàê„Åó„Å¶„Åè„Å†„Åï„ÅÑ
```

## üîí „Çª„Ç≠„É•„É™„ÉÜ„Ç£„Éô„Çπ„Éà„Éó„É©„ÇØ„ÉÜ„Ç£„Çπ

### 1. SQL „Ç§„É≥„Ç∏„Çß„ÇØ„Ç∑„Éß„É≥ÂØæÁ≠ñ

```javascript
// ‚úÖ ËâØ„ÅÑ‰æãÔºö„Éë„É©„É°„Éº„ÇøÂåñ„ÇØ„Ç®„É™
const query = "SELECT * FROM users WHERE id = $1";
const result = await db.select(query, [userId]);

// ‚ùå ÊÇ™„ÅÑ‰æãÔºöÊñáÂ≠óÂàóÁµêÂêà
const query = `SELECT * FROM users WHERE id = ${userId}`; // Âç±Èô∫ÔºÅ
```

### 2. „Ç¢„ÇØ„Çª„ÇπÂà∂Âæ°

```javascript
// ÈáçË¶Å„Å™„ÉÜ„Éº„Éñ„É´„Å∏„ÅÆ„Ç¢„ÇØ„Çª„ÇπÂà∂Èôê
const restrictedTables = ["admin_users", "payment_info", "secrets"];
if (restrictedTables.includes(tableName)) {
  throw new Error("Access denied to restricted table");
}
```

### 3. „É≠„Ç∞„ÅÆ„Çµ„Éã„Çø„Ç§„Çº„Éº„Ç∑„Éß„É≥

```javascript
// Ê©üÂØÜÊÉÖÂ†±„Çí„É≠„Ç∞„Åã„ÇâÈô§Â§ñ
const sanitizeQuery = (query) => {
  return query.replace(/password\s*=\s*['"][^'"]*['"]/gi, "password=***");
};
```

## üìà „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÊúÄÈÅ©Âåñ

### 1. Êé•Á∂ö„Éó„Éº„É™„É≥„Ç∞ÔºàÊú¨Áï™Áí∞Â¢ÉÔºâ

```javascript
import { Pool } from "pg";

const pool = new Pool({
  connectionString: config.postgresql_url,
  max: 20,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,
});
```

### 2. „ÇØ„Ç®„É™ÊúÄÈÅ©Âåñ

```javascript
// „Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÇíÊ¥ªÁî®„Åó„Åü„ÇØ„Ç®„É™
const optimizedQuery = `
  SELECT u.name, COUNT(p.id) as project_count
  FROM users u
  LEFT JOIN projects p ON u.id = p.user_id
  WHERE u.created_at >= $1
  GROUP BY u.id, u.name
  ORDER BY project_count DESC
  LIMIT $2
`;
```

## üéâ „Åæ„Å®„ÇÅ

„Åì„ÅÆ„Éá„Éº„Çø„Éô„Éº„ÇπÈÄ£Êê∫ DXT Êã°ÂºµÊ©üËÉΩ„Å´„Çà„Çä„ÄÅ‰ª•‰∏ã„ÅåÂÆüÁèæ„Åß„Åç„Åæ„Åó„ÅüÔºö

### ‚úÖ ÈÅîÊàêÈ†ÖÁõÆ

- **„Éû„É´„ÉÅ DB ÂØæÂøú**: SQLite „Å® PostgreSQL „ÅÆ‰∏°Êñπ„Çí„Çµ„Éù„Éº„Éà
- **„Çª„Ç≠„É•„Ç¢ÂÆüË£Ö**: SQL „Ç§„É≥„Ç∏„Çß„ÇØ„Ç∑„Éß„É≥ÂØæÁ≠ñ„ÄÅÂÖ•ÂäõÊ§úË®º
- **CRUD Êìç‰Ωú**: ÂÆåÂÖ®„Å™„Éá„Éº„Çø„Éô„Éº„ÇπÊìç‰ΩúÊ©üËÉΩ
- **„Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞**: Â†ÖÁâ¢„Å™„Ç®„É©„ÉºÂá¶ÁêÜ„Å®„É≠„Ç∞Âá∫Âäõ
- **Ë®≠ÂÆöÂèØËÉΩ**: „É¶„Éº„Ç∂„ÉºË®≠ÂÆö„Å´„Çà„ÇãÊüîËªü„Å™Áí∞Â¢ÉÊßãÁØâ

### üöÄ Ê¨°„ÅÆ„Çπ„ÉÜ„ÉÉ„Éó

„Åì„ÅÆÂü∫Á§é„Çí„ÇÇ„Å®„Å´„ÄÅ‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å™Êã°Âºµ„ÇÇÂèØËÉΩ„Åß„ÅôÔºö

- **È´òÂ∫¶„Å™ÂàÜÊûêÊ©üËÉΩ**: ÈõÜË®à„ÄÅ„Ç∞„É´„Éº„ÉóÂåñ„ÄÅ„Éî„Éú„ÉÉ„Éà
- **„Éá„Éº„ÇøÂèØË¶ñÂåñ**: „ÉÅ„É£„Éº„ÉàÁîüÊàê„ÄÅ„É¨„Éù„Éº„Éà‰ΩúÊàê
- **„É™„Ç¢„É´„Çø„Ç§„É†ÂêåÊúü**: WebSocket „Å´„Çà„Çã„É™„Ç¢„É´„Çø„Ç§„É†Êõ¥Êñ∞
- **„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„ÉóÊ©üËÉΩ**: Ëá™Âãï„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó„Å®„É™„Çπ„Éà„Ç¢

„Éá„Éº„Çø„Éô„Éº„ÇπÈÄ£Êê∫„Çí„Éû„Çπ„Çø„Éº„Åó„Åü„Çâ„ÄÅÊ¨°„ÅØ [„Çª„Ç≠„É•„É™„ÉÜ„Ç£„Å®„Ç®„É≥„Çø„Éº„Éó„É©„Ç§„Ç∫Ê©üËÉΩ](./05-security-enterprise.md) „Å´ÈÄ≤„Çì„Åß„ÄÅ„Çà„ÇäÈ´òÂ∫¶„Å™„Çª„Ç≠„É•„É™„ÉÜ„Ç£Ê©üËÉΩ„ÇíÂ≠¶Áøí„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ
